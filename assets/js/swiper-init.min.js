/*!
 * bs Swiper
 * 
 * @version 6.0.0
 */


/**
 * Multiple Swiper instances per page 
 * See https://raddy.co.uk/blog/multiple-instances-of-swiperjs-on-the-same-page-with-the-same-settings/
 */

/**
 * Swiper Initialization
 */
document.addEventListener('DOMContentLoaded', function () {
  // Changed selector to avoid matching wrapper divs
  const bsSwipers = document.querySelectorAll('.bs-swiper-container');
  
  console.log('Found Swiper elements:', bsSwipers.length);

  for (let i = 0; i < bsSwipers.length; i++) {
    const el = bsSwipers[i];
    
    console.log('Processing Swiper at index', i, ':', el);
    
    // CRITICAL: Verify el is a valid Element node
    if (!el || 
        !document.body.contains(el) || 
        el.nodeType !== Node.ELEMENT_NODE) {
      console.warn('Invalid Swiper element at index', i);
      continue;
    }
    
    // Check if already initialized
    if (el.classList.contains('swiper-initialized') || el.swiper) {
      console.warn('Swiper already initialized at index', i);
      continue;
    }

    const uniqueClass = 'bs-swiper-' + i;
    el.classList.add(uniqueClass);

    // Safe breakpoints parsing
    let breakpoints = {
      slidesPerView: 1,
      576: { slidesPerView: 1 },
      768: { slidesPerView: 2 },
      992: { slidesPerView: 3 },
      1200: { slidesPerView: 4 },
      1400: { slidesPerView: 4 },
    };

    try {
      const bpData = el.getAttribute('data-swiper-breakpoints');
      if (bpData) {
        breakpoints = JSON.parse(bpData);
      }
    } catch (e) {
      console.warn('Invalid Swiper breakpoints JSON:', e);
    }

    // Get settings safely
    const loopData = el.getAttribute('data-swiper-loop');
    const loop = loopData === 'true';

    const autoplayData = el.getAttribute('data-swiper-autoplay');
    const autoplayEnabled = autoplayData === 'true';
    
    const delayData = el.getAttribute('data-swiper-delay');
    const delay = delayData ? parseInt(delayData) : 4000;

    const spaceBetweenData = el.getAttribute('data-swiper-spacebetween');
    const spaceBetween = spaceBetweenData ? parseInt(spaceBetweenData) : 20;

    const effectData = el.getAttribute('data-swiper-effect');
    const effect = effectData || 'slide';

    const speedData = el.getAttribute('data-swiper-speed');
    const speed = speedData ? parseInt(speedData) : 300;

    const navigationData = el.getAttribute('data-swiper-navigation');
    const navigationEnabled = navigationData !== 'false';

    // Configure autoplay
    let autoplayConfig = false;
    if (autoplayEnabled) {
      autoplayConfig = {
        delay: delay,
        pauseOnMouseEnter: true,
        disableOnInteraction: false,
      };
    }

    // SAFE navigation configuration
    let navigationConfig = false;
    if (navigationEnabled) {
      const parent = el.parentElement;
      if (parent && 
          parent.nodeType === Node.ELEMENT_NODE && 
          document.body.contains(parent)) {
        const nextButton = parent.querySelector('.swiper-button-next');
        const prevButton = parent.querySelector('.swiper-button-prev');
        
        // Verify buttons are valid Element nodes
        if (nextButton && 
            prevButton && 
            nextButton.nodeType === Node.ELEMENT_NODE &&
            prevButton.nodeType === Node.ELEMENT_NODE &&
            document.body.contains(nextButton) && 
            document.body.contains(prevButton)) {
          navigationConfig = {
            nextEl: nextButton,
            prevEl: prevButton,
          };
        }
      }
    }

    // SAFE pagination configuration
    let paginationConfig = false;
    const parent = el.parentElement;
    if (parent && 
        parent.nodeType === Node.ELEMENT_NODE && 
        document.body.contains(parent)) {
      const paginationEl = parent.querySelector('.swiper-pagination');
      if (paginationEl && 
          paginationEl.nodeType === Node.ELEMENT_NODE &&
          document.body.contains(paginationEl)) {
        paginationConfig = {
          el: paginationEl,
          clickable: true,
        };
      }
    }

    // Effect configuration (safe - only add if effect is specified)
    let effectConfig = {};
    if (effect && effect !== 'slide') {
      switch (effect) {
        case 'fade':
          effectConfig = { fadeEffect: { crossFade: true } };
          break;
        case 'cube':
          effectConfig = { cubeEffect: { shadow: true, slideShadows: true, shadowOffset: 20, shadowScale: 0.94 } };
          break;
        case 'coverflow':
          effectConfig = { coverflowEffect: { rotate: 50, stretch: 0, depth: 100, modifier: 1, slideShadows: true } };
          break;
        case 'flip':
          effectConfig = { flipEffect: { slideShadows: true, limitRotation: true } };
          break;
        case 'cards':
          effectConfig = { cardsEffect: { slideShadows: false } };
          break;
        case 'creative':
          effectConfig = { creativeEffect: { prev: { translate: [0, 0, -400] }, next: { translate: ['100%', 0, 0] } } };
          break;
        default:
          // Unknown effect, fallback to slide
          effectConfig = {};
          break;
      }
    }

    // Build safe configuration
    const swiperConfig = {
      slidesPerView: 1,
      spaceBetween: spaceBetween,
      loop: loop,
      grabCursor: true,
      autoplay: autoplayConfig,
      effect: effect,
      speed: speed,
      breakpoints: breakpoints
    };

    // Only add effect config if we have effects
    if (Object.keys(effectConfig).length > 0) {
      Object.assign(swiperConfig, effectConfig);
    }

    // Only add navigation if configured
    if (navigationConfig) {
      swiperConfig.navigation = navigationConfig;
    }

    // Only add pagination if configured
    if (paginationConfig) {
      swiperConfig.pagination = paginationConfig;
    }

    // Layout-specific adjustments
    try {
      const wrapper = el.closest('.bs-swiper-wrapper');
      if (wrapper && wrapper.classList.contains('bs-swiper-heroes')) {
        Object.assign(swiperConfig, {
          centeredSlides: true,
          watchSlidesProgress: true,
        });
      }

      // CRITICAL: Final validation before initialization
      // Check if element still exists and has swiper-wrapper child
      const swiperWrapper = el.querySelector('.swiper-wrapper');
      
      if (!el || 
          !document.body.contains(el) || 
          el.nodeType !== Node.ELEMENT_NODE ||
          !swiperWrapper) {
        console.warn('Invalid Swiper setup for:', uniqueClass, {
          elementExists: !!el,
          inDOM: el ? document.body.contains(el) : false,
          isElement: el ? el.nodeType === Node.ELEMENT_NODE : false,
          hasWrapper: !!swiperWrapper
        });
        continue;
      }

      // Debug logging
      console.log('Swiper Init Debug at index', i, ':', {
        element: el,
        tagName: el.tagName,
        className: el.className,
        hasWrapper: !!swiperWrapper,
        hasNavigation: !!navigationConfig,
        hasPagination: !!paginationConfig,
        navigationElements: navigationConfig ? {
          nextEl: navigationConfig.nextEl,
          prevEl: navigationConfig.prevEl,
          nextElType: navigationConfig.nextEl?.nodeType,
          prevElType: navigationConfig.prevEl?.nodeType
        } : null,
        paginationElement: paginationConfig ? {
          el: paginationConfig.el,
          elType: paginationConfig.el?.nodeType
        } : null
      });
      
      // Initialize Swiper with the element directly
      new Swiper(el, swiperConfig);
      
    } catch (error) {
      console.error('Error initializing Swiper at index', i, ':', error);
      console.log('Element:', el);
      console.log('Config:', swiperConfig);
    }
  }
});
          